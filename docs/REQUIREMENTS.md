# 요구사항 분석 및 설계 결정

## 1. 기획팀 요청사항 분석

### 1.1 명시된 요구사항

| 구분 | 요구사항 |
|------|----------|
| 기능 | 학생 목록 조회, 강좌 목록 조회(전체/학과별), 교수 목록 조회 |
| 기능 | 수강신청, 수강취소, 내 시간표(이번 학기) 조회 |
| 제약 | 학생당 최대 18학점 |
| 제약 | 동일 시간대 중복 수강 불가 |
| 핵심 | 정원 초과 절대 방지 (동시성 제어) |
| 범위 | 서버(백엔드)만 구현, 프론트엔드 제외 |

### 1.2 도출된 암묵적 요구사항

| 구분 | 결정 사항 | 근거 |
|------|-----------|------|
| 동일 강좌 중복 신청 | 불가 | 같은 강좌를 두 번 신청하는 것은 비합리적. DB에 student+course 복합 유니크 제약 추가 |
| 인증/인가 | 미구현 (학생 ID 기반) | 핵심 기능 우선, 프론트팀 연동 전 단계. 향후 Spring Security 도입 가능 |
| 수강취소 기한 | 제한 없음 | 명시되지 않았으므로 자유롭게 취소 가능 |
| 재수강 | 허용하지 않음 | 이번 학기 수강신청만 다루므로 재수강 개념 불필요 |
| 선수과목/학년 제한 | 미구현 | 핵심 기능 우선 구현 후 확장 가능 |
| 동시 중복 신청 | 비관적 락으로 방지 | 동일 학생이 같은 강좌를 동시에 여러 번 요청해도 1번만 성공 |

---

## 2. 설계 결정

### 2.1 데이터베이스 선택: H2 인메모리

- **근거**: 별도 DB 설치 없이 실행 가능, 빠른 데이터 초기화, 평가자 편의성
- **트레이드오프**: 서버 재시작 시 데이터 초기화 (과제 특성상 문제 없음)
- **부가 기능**: `/h2-console/` 경로로 웹 콘솔 접근 가능 (데이터 확인 용이)

### 2.2 동시성 제어 전략: 비관적 락 (Pessimistic Lock)

- **근거**: 수강신청은 경합이 높은 시나리오(정원 1명 남은 강좌에 100명 동시 신청)
- **구현**: JPA의 `@Lock(LockModeType.PESSIMISTIC_WRITE)`를 활용한 행 수준 락
- **적용 위치**: `CourseRepository.findByIdWithLock()` - 수강신청/취소 시 Course 행을 잠금
- **트레이드오프**: 낙관적 락 대비 성능은 낮으나, 정원 초과 방지의 확실성이 높음
- **대안 검토**:
  - 낙관적 락(`@Version`): 재시도 로직이 필요하고, 높은 경합 상황에서 다수의 재시도 발생 → 사용자 경험 저하
  - 분산 락(Redis): 인메모리 DB 환경에서 과도한 인프라 복잡도 → 불필요

**검증 결과** (테스트로 확인):
- 정원 1명 강좌에 100명 동시 신청 → 정확히 1명만 성공
- 정원 30명 강좌에 100명 동시 신청 → 정확히 30명만 성공
- 동일 학생 동시 중복 신청 → 1번만 성공
- 수강신청/취소 동시 발생 → enrolled 카운트 정확

### 2.3 시간표 슬롯 정의

| 항목 | 설계 |
|------|------|
| 요일 | 월, 화, 수, 목, 금 (주 5일) |
| 시간 범위 | 09:00 ~ 17:30 |
| 슬롯 | 09:00-10:30, 10:30-12:00, 13:00-14:30, 14:30-16:00, 16:00-17:30 |
| 표현 방식 | `"요일 HH:mm-HH:mm"` (예: `"월 09:00-10:30"`) |

### 2.4 학점 설계

| 항목 | 설계 |
|------|------|
| 학점 범위 | 1 ~ 4학점 |
| 최대 신청 학점 | 18학점 |
| 학점 분포 | 1학점(10%), 2학점(20%), 3학점(50%), 4학점(20%) |

### 2.5 시간 충돌 판단 로직

- 두 강좌의 **요일이 동일**하고, **시간 구간이 겹치면** 충돌로 판단
- 충돌 조건: `start1 < end2 && start2 < end1`
- 경계는 허용: "월 09:00-10:30"과 "월 10:30-12:00"은 **충돌하지 않음**
- 예시:
  - `"월 09:00-10:30"` vs `"월 10:00-11:30"` → **충돌**
  - `"월 09:00-10:30"` vs `"월 10:30-12:00"` → **비충돌**
  - `"월 09:00-10:30"` vs `"화 09:00-10:30"` → **비충돌**

---

## 3. API 설계 원칙

- RESTful 리소스 중심 설계
- 일관된 에러 응답 형식: `{ "error": "에러 메시지", "code": "ERROR_CODE" }`
- 적절한 HTTP 상태 코드 사용 (200, 201, 404, 409)
- 비즈니스 규칙 위반은 409 Conflict로 응답 (정원 초과, 학점 초과, 시간 충돌, 중복 신청)

---

## 4. 데이터 생성 전략

- **방식**: `ApplicationRunner` 구현으로 서버 시작 시 동적 생성
- **소요 시간**: 약 5초 (1분 이내 요구사항 충족)
- **이름 생성**: 한국식 성(20개) + 이름(30개) 토큰 조합
- **학과**: 15개 실제 대학 학과명 (컴퓨터공학과, 경영학과, 법학과 등)
- **강좌명**: 학과별 10~15개 실제 강좌명 × 3~4 분반 = 547개
- **학번**: `{입학년도}{일련번호}` 형식 (예: `202300001`)
- **배치 삽입**: Hibernate batch_size=100 설정으로 대량 데이터 삽입 최적화

### 데이터 정합성 보장

- 교수는 반드시 학과에 소속
- 강좌는 반드시 학과와 교수에 연결
- 학생은 반드시 학과에 소속
- 초기 데이터에서 수강신청은 생성하지 않음 (비즈니스 규칙 위반 방지)

---

## 5. 테스트 전략

### 5.1 동시성 테스트 (EnrollmentConcurrencyTest)

| 테스트 | 검증 내용 |
|--------|-----------|
| 정원 1명 × 100명 동시 | `ExecutorService` 100스레드, 정확히 1명만 성공 |
| 정원 30명 × 100명 동시 | 정확히 30명만 성공, enrolled=30 |
| 동일 학생 중복 동시 신청 | 10스레드 동시, 1번만 성공 |
| 신청/취소 동시 수행 | enrolled 카운트 = 실제 수강 기록 수 일치 |

### 5.2 비즈니스 규칙 테스트 (EnrollmentServiceTest)

| 테스트 | 검증 내용 |
|--------|-----------|
| 수강신청 성공 | enrolled 증가, 응답 데이터 정확 |
| 정원 초과 | CAPACITY_EXCEEDED 에러 |
| 중복 신청 | ALREADY_ENROLLED 에러 |
| 학점 초과 | 16학점 등록 후 3학점 추가 → CREDIT_LIMIT_EXCEEDED |
| 시간 충돌 | 같은 요일 겹치는 시간 → SCHEDULE_CONFLICT |
| 경계 시간 | 10:30 끝 → 10:30 시작은 충돌 아님 |
| 수강취소 | enrolled 감소, 수강 기록 삭제 |
| 미존재 취소 | ENROLLMENT_NOT_FOUND 에러 |
| 시간표 조회 | 수강 목록 + 총 학점 반환 |
