# 요구사항 분석 및 설계 결정

## 1. 기획팀 요청사항 분석

### 1.1 명시된 요구사항

| 구분 | 요구사항 |
|------|----------|
| 기능 | 학생 목록 조회, 강좌 목록 조회(전체/학과별), 교수 목록 조회 |
| 기능 | 수강신청, 수강취소, 내 시간표(이번 학기) 조회 |
| 제약 | 학생당 최대 18학점 |
| 제약 | 동일 시간대 중복 수강 불가 |
| 핵심 | 정원 초과 절대 방지 (동시성 제어) |
| 범위 | 서버(백엔드)만 구현, 프론트엔드 제외 |

### 1.2 도출된 암묵적 요구사항

#### 구현 완료

| 구분 | 결정 사항 | 근거 |
|------|-----------|------|
| 동일 강좌 중복 신청 | 불가 | 같은 강좌를 두 번 신청하는 것은 비합리적. DB에 student+course 복합 유니크 제약 추가 |
| 같은 과목 타 분반 중복 신청 | 불가 | "자료구조 1분반"을 신청한 학생이 "자료구조 2분반"을 추가 신청하는 것은 비합리적. Course의 baseName 필드로 동일 과목 판별 |
| 동시 중복 신청 | 비관적 락으로 방지 | 동일 학생이 같은 강좌를 동시에 여러 번 요청해도 1번만 성공 |

#### 미구현 (향후 확장 가능)

**1. 인증/인가**
- **현재**: 학생 ID를 요청 파라미터로 직접 전달하는 방식
- **구현 시 오버헤드**: User 테이블 추가, 비밀번호 해싱(BCrypt), JWT 토큰 발급/검증 로직, Spring Security 필터 체인 설정, 로그인/로그아웃 API 추가
- **향후 방안**: Spring Security + JWT 기반 인증 도입. `SecurityFilterChain`에서 토큰 검증 후 `SecurityContextHolder`로 학생 정보를 주입하면 기존 서비스 로직의 변경을 최소화할 수 있음

**2. 수강취소 기한**
- **현재**: 기한 제한 없이 자유롭게 취소 가능
- **구현 시 오버헤드**: Enrollment 엔티티에 `enrolledAt` 타임스탬프 필드 추가, 수강신청 기간을 관리하는 `EnrollmentPeriod` 엔티티/테이블 신설, 취소 가능 여부를 판단하는 서비스 로직 추가
- **향후 방안**: `EnrollmentPeriod(startDate, endDate, cancelDeadline)` 엔티티를 도입하고, 취소 API에서 `LocalDateTime.now()`와 `cancelDeadline`을 비교하여 기한 초과 시 거절

**3. 재수강**
- **현재**: 허용하지 않음 (이번 학기 수강신청만 관리)
- **구현 시 오버헤드**: 학기(Semester) 엔티티 신설, 과거 수강 이력(EnrollmentHistory) 테이블 추가, 성적(Grade) 엔티티 추가, DataInitializer에 과거 학기 수강 이력 시드 데이터 생성 필요
- **향후 방안**: `Enrollment`에 `semester` 필드를 추가하고, `EnrollmentHistory` 테이블에서 이전 학기 이수 내역을 관리. 재수강 신청 시 해당 과목의 이전 성적을 조회하여 재수강 허용 조건(F 또는 D 이하)을 검증

**4. 선수과목/학년 제한**
- **현재**: 미구현
- **구현 시 오버헤드**: Course 엔티티에 `prerequisiteCourses` 다대다 자기참조 관계 추가, `minGrade`(최소 학년) 필드 추가, 수강 이력 테이블을 통한 선수과목 이수 여부 조회 쿼리 필요, DataInitializer에 선수과목 관계 시드 데이터 생성
- **향후 방안**: `course_prerequisite` 조인 테이블로 선수과목 관계를 매핑하고, 수강신청 시 `EnrollmentHistory`에서 해당 선수과목 이수 완료 여부를 검증. 학년 제한은 `Student.grade >= Course.minGrade` 조건 추가

---

## 2. 설계 결정

### 2.1 데이터베이스 선택: H2 인메모리

- **근거**: 별도 DB 설치 없이 실행 가능, 빠른 데이터 초기화, 평가자 편의성
- **트레이드오프**: 서버 재시작 시 데이터 초기화 (과제 특성상 문제 없음)
- **부가 기능**: `/h2-console/` 경로로 웹 콘솔 접근 가능 (데이터 확인 용이)

### 2.2 동시성 제어 전략

수강신청의 핵심 문제: **"정원 1명 남은 강좌에 100명이 동시 신청 → 정확히 1명만 성공"**을 보장해야 한다.

#### 검토한 전략

**1. 비관적 락 (Pessimistic Lock) — 채택**

`SELECT ... FOR UPDATE`로 Course 행을 잠그고, 트랜잭션이 끝날 때까지 다른 트랜잭션은 대기.

- 장점: 정합성 확실 보장, 재시도 로직 불필요, 구현 단순(`@Lock` 어노테이션), 높은 경합에서 불필요한 롤백 없음
- 단점: 같은 강좌 요청이 직렬화되어 처리량 저하, 데드락 가능성, 락 대기 중 DB 커넥션 점유

**2. 낙관적 락 (Optimistic Lock) — 미채택**

`@Version` 필드로 커밋 시 충돌 감지. 충돌 시 `OptimisticLockException` 발생 후 애플리케이션에서 재시도.

- 장점: 락 없이 읽기 성능 우수, 커넥션 점유 시간 짧음, 데드락 없음
- 단점: 재시도 로직 직접 구현 필요, 정원 1명×100명 시 99명이 롤백+재시도 반복(retry storm), 응답 시간 증가

**3. 분산 락 (Redis) — 미채택**

Redis `SETNX` 또는 Redisson `RLock`으로 애플리케이션 레벨 락 획득.

- 장점: DB 락 부하 없음, 다중 서버(Scale-out) 환경 대응, 세밀한 타임아웃 제어
- 단점: Redis 인프라 추가 필요, Redis 장애 시 SPOF, 락 해제와 트랜잭션 커밋 간 정합성 보장 어려움

**4. 네임드 락 (Named Lock / Advisory Lock) — 미채택**

DB의 사용자 정의 이름 기반 락 (`GET_LOCK('course_1', 5)`).

- 장점: 별도 인프라 불필요, 행 잠금이 아니라 조회에 영향 없음, 유연한 범위 설정
- 단점: DB 벤더 종속(MySQL/PostgreSQL), **H2 미지원**으로 현재 프로젝트 적용 불가

**5. 큐 기반 순차 처리 (Message Queue) — 미채택**

수강신청 요청을 Kafka/RabbitMQ 큐에 넣고 컨슈머가 순차 처리.

- 장점: 동시성 문제를 구조적으로 제거, 트래픽 스파이크 흡수, 다중 서버 대응
- 단점: 비동기 처리로 즉시 응답 불가, MQ 인프라 필요, 구현 복잡도 대폭 증가

#### 전략 비교 요약

| 전략 | 정합성 | 구현 복잡도 | 처리량 | 추가 인프라 | 채택 여부 |
|------|:------:|:---------:|:-----:|:---------:|:-------:|
| **비관적 락** | **확실** | **낮음** | 중간 | **없음** | **채택** |
| 낙관적 락 | 재시도 의존 | 중간 | 높음(저경합) | 없음 | 미채택 |
| 분산 락 (Redis) | 높음 | 높음 | 높음 | Redis | 미채택 |
| 네임드 락 | 높음 | 중간 | 중간 | 없음 | 미채택 |
| 큐 기반 | 확실 | 매우 높음 | 높음 | MQ | 미채택 |

#### 채택 근거

- **시나리오 특성**: 인기 강좌에 수백 명이 동시 접근하는 **높은 경합** 환경. 낙관적 락의 retry storm보다 비관적 락의 순차 대기가 사용자 경험과 정합성 면에서 유리
- **인프라 제약**: 단일 서버 + H2 인메모리 환경에서 Redis/MQ는 과도한 복잡도
- **확장 전략**: 향후 다중 서버 전환 시 Redis 분산 락 또는 큐 기반 구조로 확장 가능

#### 구현 방식

- JPA `@Lock(LockModeType.PESSIMISTIC_WRITE)`를 활용한 행 수준 락
- 적용 위치: `CourseRepository.findByIdWithLock()` — 수강신청/취소 시 Course 행 잠금

#### 검증 결과 (테스트로 확인)

- 정원 1명 강좌에 100명 동시 신청 → 정확히 1명만 성공
- 정원 30명 강좌에 100명 동시 신청 → 정확히 30명만 성공
- 동일 학생 동시 중복 신청 → 1번만 성공
- 수강신청/취소 동시 발생 → enrolled 카운트 정확

### 2.3 시간표 슬롯 정의

| 항목 | 설계 |
|------|------|
| 요일 | 월, 화, 수, 목, 금 (주 5일) |
| 시간 범위 | 09:00 ~ 17:30 |
| 슬롯 | 09:00-10:30, 10:30-12:00, 13:00-14:30, 14:30-16:00, 16:00-17:30 |
| 표현 방식 | `"요일 HH:mm-HH:mm"` (예: `"월 09:00-10:30"`) |

### 2.4 학점 설계

| 항목 | 설계 |
|------|------|
| 학점 범위 | 1 ~ 4학점 |
| 최대 신청 학점 | 18학점 |
| 학점 분포 | 1학점(10%), 2학점(20%), 3학점(50%), 4학점(20%) |

### 2.5 시간 충돌 판단 로직

- 두 강좌의 **요일이 동일**하고, **시간 구간이 겹치면** 충돌로 판단
- 충돌 조건: `start1 < end2 && start2 < end1`
- 경계는 허용: "월 09:00-10:30"과 "월 10:30-12:00"은 **충돌하지 않음**
- 예시:
  - `"월 09:00-10:30"` vs `"월 10:00-11:30"` → **충돌**
  - `"월 09:00-10:30"` vs `"월 10:30-12:00"` → **비충돌**
  - `"월 09:00-10:30"` vs `"화 09:00-10:30"` → **비충돌**

---

## 3. API 설계 원칙

- RESTful 리소스 중심 설계
- 일관된 에러 응답 형식: `{ "error": "에러 메시지", "code": "ERROR_CODE" }`
- 적절한 HTTP 상태 코드 사용 (200, 201, 404, 409)
- 비즈니스 규칙 위반은 409 Conflict로 응답 (정원 초과, 학점 초과, 시간 충돌, 중복 신청)

---

## 4. 데이터 생성 전략

- **방식**: `ApplicationRunner` 구현으로 서버 시작 시 동적 생성
- **소요 시간**: 약 5초 (1분 이내 요구사항 충족)
- **이름 생성**: 한국식 성(20개) + 이름(30개) 토큰 조합
- **학과**: 15개 실제 대학 학과명 (컴퓨터공학과, 경영학과, 법학과 등)
- **강좌명**: 학과별 10~15개 실제 강좌명 × 3~4 분반 = 547개
- **학번**: `{입학년도}{일련번호}` 형식 (예: `202300001`)
- **배치 삽입**: Hibernate batch_size=100 설정으로 대량 데이터 삽입 최적화

### 데이터 정합성 보장

- 교수는 반드시 학과에 소속
- 강좌는 반드시 학과와 교수에 연결
- 학생은 반드시 학과에 소속
- 초기 데이터에서 수강신청은 생성하지 않음 (비즈니스 규칙 위반 방지)

---

## 5. 테스트 전략

### 5.1 동시성 테스트 (EnrollmentConcurrencyTest)

| 테스트 | 검증 내용 |
|--------|-----------|
| 정원 1명 × 100명 동시 | `ExecutorService` 100스레드, 정확히 1명만 성공 |
| 정원 30명 × 100명 동시 | 정확히 30명만 성공, enrolled=30 |
| 동일 학생 중복 동시 신청 | 10스레드 동시, 1번만 성공 |
| 신청/취소 동시 수행 | enrolled 카운트 = 실제 수강 기록 수 일치 |

### 5.2 비즈니스 규칙 테스트 (EnrollmentServiceTest)

| 테스트 | 검증 내용 |
|--------|-----------|
| 수강신청 성공 | enrolled 증가, 응답 데이터 정확 |
| 정원 초과 | CAPACITY_EXCEEDED 에러 |
| 중복 신청 | ALREADY_ENROLLED 에러 |
| 같은 과목 타 분반 | SAME_COURSE_ENROLLED 에러 |
| 학점 초과 | 16학점 등록 후 3학점 추가 → CREDIT_LIMIT_EXCEEDED |
| 시간 충돌 | 같은 요일 겹치는 시간 → SCHEDULE_CONFLICT |
| 경계 시간 | 10:30 끝 → 10:30 시작은 충돌 아님 |
| 수강취소 | enrolled 감소, 수강 기록 삭제 |
| 미존재 취소 | ENROLLMENT_NOT_FOUND 에러 |
| 시간표 조회 | 수강 목록 + 총 학점 반환 |
