# 기술 논의 기록

> 수강신청 시스템 프로젝트를 기반으로 진행한 기술 논의를 정리한다.
> 각 주제별로 질문 → 분석 → 결론 순서로 기록한다.

---

## 1. H2는 Spring 라이브러리인가?

**결론: 아니다.**

H2는 Spring과 무관한 독립적인 Java 기반 오픈소스 데이터베이스다.

| 구분 | 예시 |
|------|------|
| Spring 라이브러리 | Spring Data JPA, Spring Security, Spring MVC |
| Spring이 아닌 것 | H2, MySQL, Lombok, Swagger (springdoc) |

Spring Boot가 H2에 대한 자동 설정(Auto-Configuration)을 제공하기 때문에 마치 Spring의 일부처럼 느껴질 수 있지만, H2 자체는 독립 프로젝트다.

정확한 표현: "Spring Data JPA를 통해 H2 데이터베이스를 연동했다"

---

## 2. FastAPI로 전환한다면 H2를 사용할 수 있는가?

**결론: 사용할 수 없다.**

H2는 JVM 기반 데이터베이스로, Python에서 사용하려면 JVM을 별도로 띄우고 JDBC 브릿지를 거쳐야 해서 비현실적이다.

| FastAPI 대안 | 특징 |
|-------------|------|
| **SQLite** | H2와 가장 유사한 경량 내장 DB. Python 내장 모듈로 설치 불필요 |
| **PostgreSQL** | 동시성 제어가 중요하다면 가장 적합. write lock이 단일인 SQLite보다 유리 |

---

## 3. 도커라이징 장단점

**결론: 현재 과제에서는 도입하지 않는 것이 적절하다.**

| 장점 | 단점 |
|------|------|
| 실행 환경 통일 ("제 컴퓨터에서는 되는데요" 방지) | 평가자에게 Docker 설치 필요 (진입 장벽) |
| Java/Gradle 설치 없이 `docker-compose up` 실행 | H2와 Docker는 어색한 조합 |
| 프로덕션 유사 환경 | 빌드 시간 증가, 디버깅 불편 |

**핵심 판단 기준**: 과제 요구사항이 "별도 DB 설치 없이 실행"이므로 H2 + `gradlew bootRun`이 가장 부합한다. Docker를 도입한다면 H2를 MySQL로 전환해야 의미가 살아난다.

---

## 4. 강좌 조회 캐싱 전략

### 4.1 문제 인식

수강신청 시 학생 행동 패턴은 "강좌 목록 조회(여러 번) → 수강신청(1번)"이다. 읽기:쓰기 비율이 10:1 이상이므로 `GET /courses`가 트래픽 대부분을 차지한다.

### 4.2 일반적인 TTL 캐싱의 한계

| TTL | DB 부하 감소 | 문제 |
|-----|:---------:|------|
| 1~3초 | 낮음 | 캐시 히트율 낮아 효과 제한적 |
| 10~30초 | 높음 | 정원 마감 강좌가 여석 있는 것처럼 보임 |
| 1~5분 | 매우 높음 | 잔여 정원 정보 신뢰도 하락 |

### 4.3 도메인 특성 기반 Write-Through 전략

**결론: 수강신청 도메인에서는 TTL 기반보다 Write-Through 캐시가 최적이다.**

핵심 통찰: 수강신청은 **정원이 단방향으로 차는 구조**다.

```
정원 40 → 39 → 38 → ... → 1 → 0 (마감)
         ↑ 이 구간만 쓰기 발생       ↑ 이후 100% 캐시 히트
```

- 쓰기는 최대 정원 수만큼만 발생
- 마감 후 모든 조회는 캐시에서 처리
- 스파이크 구간에서 취소는 거의 없음
- 인기 강좌일수록 빨리 마감 → 빨리 캐시 히트율 100% 도달

**동작 흐름**:

```
[GET /courses 조회]
  → 캐시 존재? → 캐시 반환 (DB 안 감)
  → 캐시 없음? → DB 조회 → 캐시 저장 → 반환

[POST /enrollments 수강신청]
  → DB 비관적 락 → 검증 → enrolled 증가 → DB 커밋
  → 캐시에 해당 강좌의 enrolled 값 즉시 갱신 (write-through)
```

**TTL 기반 대비 장점**:

| 항목 | TTL 기반 | Write-Through |
|------|:-------:|:------------:|
| stale 데이터 | TTL 만료 전까지 발생 | 없음 |
| 잔여 정원 정확도 | 부정확 | 항상 정확 |
| 캐시 무효화 복잡도 | TTL 설정 고민 | 단순 (등록/취소 시 갱신) |

**캐시 히트율 시뮬레이션**:

| 시나리오 | 정원 | 조회 요청 수 | 캐시 히트율 |
|---------|:----:|:----------:|:--------:|
| 인기 강좌 | 30명 | 5,000건 | 99.4% |
| 일반 강좌 | 40명 | 1,000건 | 96% |

---

## 5. 단일 서버 vs 다중 서버 아키텍처

**결론: 대학교 도메인에서는 단일 서버 최적화가 현실적이다.**

### 5.1 근거

대학교는 IT 기업이 아니다. 수강신청은 **학기에 2~3회, 각 3~10분** 발생하는 이벤트다.

| 구분 | 다중 서버 (K8s + Kafka + Redis Cluster) | 단일 서버 최적화 |
|------|:------------------------------------:|:------------:|
| 인프라 비용 | 월 수백만 원 (상시 운영) | 서버 1대 유지비 |
| 운영 인력 | DevOps 전담 필요 | 기존 전산팀으로 충분 |
| 활용률 | 연간 99% 시간 유휴 | 서버 자원 상시 활용 |

### 5.2 단일 서버 최적화 전략 3가지

1. **서버 성능 극대화**: Caffeine 캐시, HikariCP 튜닝, JVM G1 GC, MySQL InnoDB 최적화
2. **트래픽 유입 제어**: Nginx Rate Limiting, 대기열 페이지, 학년별 시차 배정
3. **장애 빠른 대응**: Resilience4j Circuit Breaker, Prometheus + Grafana 모니터링

---

## 6. Nginx에서 JWT 학년 필터링 가능 여부

### 6.1 질문

1~4학년 수강신청 날짜를 각각 다르게 하고, Nginx에서 JWT 토큰의 학년 정보로 필터링할 수 있는가?

### 6.2 분석

**오픈소스 Nginx는 JWT를 네이티브로 파싱할 수 없다.** JWT 지원(`auth_jwt`)은 Nginx Plus(유료) 전용이다.

| 우회 방법 | JWT 디코딩 | 서명 검증 | 추가 인프라 |
|----------|:--------:|:-------:|:--------:|
| njs 모듈 | O | X | Docker 필요 |
| OpenResty + Lua | O | O | OpenResty 컨테이너 |
| C 모듈 컴파일 | O | O | 빌드 환경 |

**핵심 문제**: njs로 JWT payload를 Base64 디코딩할 수 있지만, 서명 검증이 안 된다. 공격자가 JWT의 grade를 조작하면 Nginx가 그대로 통과시킨다.

### 6.3 결론: Spring Boot Filter에서 처리

```
[Nginx로 필터링] → 서명 검증 불가 → Spring Boot에서 다시 검증해야 함 → 이중 작업

[Spring Boot에서 필터링] → 서명 검증 + 학년 필터링을 한 곳에서 완결 → 단순하고 안전
```

Nginx는 Rate Limiting, 리버스 프록시, 대기열 페이지 등 본래 역할에 집중하고, JWT 기반 비즈니스 로직(학년 필터링)은 Spring Boot `OncePerRequestFilter`에서 처리하는 것이 올바른 역할 분리다.

---

## 7. Nginx를 프로젝트 내부에서 설정할 수 있는가?

### 7.1 결론

**설정 파일은 프로젝트 내부에 둘 수 있지만, 실행은 반드시 별도 프로세스**다.

Nginx는 C 기반 웹 서버이므로 Spring Boot(Java)에 내장할 수 없다. Docker Compose를 사용하면 프로젝트 폴더 안에서 가장 가깝게 완결할 수 있다.

### 7.2 프로젝트 구조

```
courseRegistrationSystem/
├── docker-compose.yml
├── Dockerfile
├── nginx/
│   ├── nginx.conf
│   └── static/
│       └── waiting.html       ← 과부하 시 대기 페이지
├── src/
└── build.gradle
```

### 7.3 Nginx 설정 핵심

| 역할 | 설정 |
|------|------|
| 수강신청 API 제한 | IP당 초당 2개, 동시 3개 연결 |
| 일반 API 제한 | IP당 초당 10개, 동시 10개 연결 |
| Rate Limit 초과 | 429 JSON 응답 |
| 백엔드 다운 시 | 정적 대기 페이지 (5초 후 자동 재시도) |
| 커넥션 효율 | `keepalive 32` (TCP 핸드셰이크 재사용) |

### 7.4 요청 흐름

```
[사용자]
   │
[Nginx :80]
   ├── Rate Limiting (IP 기반)
   ├── 동시 접속 제한
   ├── 과부하 시 → waiting.html 반환
   │
   └── [Spring Boot :8080]
         ├── JWT 서명 검증 + 학년 필터링
         ├── Resilience4j (사용자별 Rate Limit + Circuit Breaker)
         └── 비즈니스 로직 (비관적 락)
```

---

## 8. Docker 환경에서 H2를 계속 사용할 의미가 있는가?

### 8.1 결론: 없다. MySQL로 전환하는 것이 자연스럽다.

Docker를 쓰는 순간 H2의 핵심 장점("별도 설치 없이 실행")이 사라진다. `docker-compose up`으로 컨테이너를 띄우는 상황에서 DB 컨테이너 하나 추가하는 비용은 거의 없다.

```
[Docker 없이] → 평가자가 Java만 있으면 실행 → H2 내장이 장점
[Docker 도입] → 어차피 Docker 필요 → DB 컨테이너 추가 비용 ≈ 0 → H2를 쓸 이유 없음
```

### 8.2 MySQL 전환 시 추가로 얻는 것

| H2에서 못 쓰던 것 | MySQL |
|------------------|:-----:|
| Named Lock (`GET_LOCK`) | O |
| 데드락 자동 감지 | O |
| InnoDB 버퍼 풀 튜닝 | O |
| 프로덕션과 동일한 환경 테스트 | O |

### 8.3 데이터 휘발성 유지

채점자는 수많은 지원자의 코드를 실행하므로, 데이터가 영속될 필요가 없다. 서버 구동 시 DataInitializer가 데이터를 생성하므로 매번 새로 시작하는 것이 바람직하다.

**volumes를 마운트하지 않으면** 컨테이너 삭제 시 데이터가 자동 소멸한다:

```yaml
services:
  db:
    image: mysql:8.0
    environment:
      MYSQL_DATABASE: coursedb
      MYSQL_ROOT_PASSWORD: password
    # volumes 없음 → 컨테이너 삭제 시 데이터 소멸
```

```
docker-compose up   → MySQL 시작 → Spring Boot 시작 → 데이터 생성
docker-compose down → MySQL 컨테이너 삭제 → 데이터 소멸 (깔끔한 초기 상태)
다시 up             → 새로운 MySQL → 새로운 데이터 생성
```

H2 인메모리와 동일한 휘발성을 유지하면서, MySQL의 기능을 모두 사용할 수 있다.

---

## 논의 주제 흐름도

```
과제 분석
  │
  ├─ 기술 스택 선택 근거 정리 (면접 준비)
  │
  ├─ 프로덕션 전환 시 변경사항 분석
  │     │
  │     ├─ 다중 서버? → 대학 도메인상 비용 과다 → 단일 서버 최적화로 방향 전환
  │     │
  │     ├─ 캐싱 전략? → 도메인 특성 분석 → Write-Through 캐시 도출
  │     │
  │     └─ Nginx 역할?
  │           ├─ JWT 필터링 → 서명 검증 불가 → Spring Boot에서 처리
  │           └─ Rate Limiting, 대기열 → Nginx가 적합
  │
  └─ 도커라이즈?
        ├─ 과제에서는 불필요 (H2 + gradlew bootRun이 최적)
        └─ 도입한다면 H2 → MySQL 전환이 자연스러움
              └─ 데이터 휘발성은 volumes 미설정으로 유지
```