# 면접 준비 가이드

## 1. 설계 의사결정 설명

### 1.1 폴더 구조: 왜 계층형(Layered) 구조인가?

```
src/main/java/com/example/courseRegistrationSystem/
├── controller/        # API 진입점 (요청/응답 처리)
│   └── docs/          # Swagger 어노테이션 분리
├── service/           # 비즈니스 로직
├── repository/        # 데이터 접근 (JPA)
├── entity/            # DB 테이블 매핑 (JPA Entity)
├── dto/               # 요청/응답 데이터 전송 객체
├── config/            # 설정 (DataInitializer, Swagger, H2)
└── exception/         # 예외 처리 (GlobalExceptionHandler)
```

**채택 근거 (과제 요구사항 기반)**

| 요구사항 | 구조적 대응 |
|----------|------------|
| REST API 서버 구현 | Controller-Service-Repository 3계층으로 관심사 분리 |
| 수강신청/취소 비즈니스 규칙 다수 | Service 계층에 비즈니스 로직을 집중하여 단일 책임 원칙 준수 |
| 일관된 에러 응답 형식 | exception 패키지의 GlobalExceptionHandler에서 일괄 처리 |
| Swagger 문서화 | controller/docs에 Swagger 어노테이션을 인터페이스로 분리하여 컨트롤러 가독성 유지 |
| 대량 초기 데이터 생성 | config/DataInitializer로 분리하여 비즈니스 로직과 독립적으로 관리 |

**도메인형(DDD) 구조를 선택하지 않은 이유**

도메인이 Enrollment 중심으로 단순하고, 엔티티 수가 5개(Department, Professor, Course, Student, Enrollment)로 적다. 도메인별로 패키지를 나누면 오히려 파일 탐색이 불편해지고 과도한 추상화가 된다. 과제의 규모와 복잡도에 맞는 구조를 선택했다.

---

### 1.2 기술 스택: 왜 이 조합인가?

#### Spring Boot 4.0.2 + Java 17

| 요구사항 | Spring Boot가 적합한 이유 |
|----------|--------------------------|
| REST API 서버 | Spring MVC가 RESTful API 구축에 최적화 |
| JPA + 비관적 락 | `@Lock(PESSIMISTIC_WRITE)` 어노테이션 한 줄로 구현 가능 |
| 트랜잭션 관리 | `@Transactional`로 선언적 트랜잭션 처리 |
| 대량 데이터 초기화 | `ApplicationRunner` + Hibernate batch 설정으로 효율적 삽입 |
| Bean Validation | `@Valid`, `@NotNull` 등으로 요청 검증 |

#### H2 인메모리 DB

| 요구사항 | H2가 적합한 이유 |
|----------|-----------------|
| 별도 DB 설치 없이 실행 | 내장 DB로 `gradle bootRun`만으로 즉시 실행 |
| 서버 시작 시 데이터 동적 생성 | `ddl-auto: create`로 매 실행마다 스키마 재생성 |
| 평가자 편의성 | 추가 인프라 설치 불필요, `/h2-console`로 데이터 직접 확인 가능 |
| 비관적 락 지원 | H2도 `SELECT ... FOR UPDATE` 지원 (Named Lock은 미지원) |

#### Lombok

| 요구사항 | 역할 |
|----------|------|
| 보일러플레이트 감소 (CLAUDE.md 명시) | `@Getter`, `@Builder`, `@NoArgsConstructor`로 Entity/DTO 간결화 |

#### springdoc-openapi (Swagger)

| 요구사항 | 역할 |
|----------|------|
| API 문서화 및 테스트 편의 | `/swagger-ui/index.html`에서 모든 API 즉시 테스트 가능 |

---

### 1.3 동시성 제어: 왜 비관적 락인가?

**핵심 시나리오**: 정원 1명 남은 강좌에 100명이 동시 신청 → 정확히 1명만 성공해야 한다.

```java
// CourseRepository.java
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("SELECT c FROM Course c WHERE c.id = :id")
Optional<Course> findByIdWithLock(@Param("id") Long id);
```

**비관적 락을 선택한 3가지 이유**

1. **높은 경합 환경**: 수강신청은 특정 인기 강좌에 수백 명이 동시 접근하는 특성이 있다. 낙관적 락은 충돌 시 롤백 후 재시도해야 하므로 retry storm이 발생한다(99명이 반복 재시도). 비관적 락은 순차 대기하므로 불필요한 롤백이 없다.
2. **구현 단순성**: JPA `@Lock` 어노테이션 한 줄로 구현 완료. 재시도 로직, 백오프 전략 등 추가 코드가 불필요하다.
3. **인프라 제약**: 단일 서버 + H2 환경에서 Redis 분산 락이나 MQ는 과도한 복잡도를 추가한다.

---

### 1.4 데이터 초기화: 왜 ApplicationRunner인가?

| 대안 | 미채택 이유 |
|------|------------|
| `data.sql` / `import.sql` | 10,000명의 학생 INSERT문을 정적으로 작성하는 것은 비현실적. 유지보수 어려움 |
| Flyway / Liquibase | 마이그레이션 도구는 스키마 관리에 적합하지, 대량 시드 데이터 동적 생성에는 오버스펙 |
| `@PostConstruct` | 트랜잭션 컨텍스트 보장이 어렵고, 빈 생성 순서에 의존 |

**ApplicationRunner 채택 이유**:
- Spring Context 완전 초기화 후 실행되어 안전
- Repository를 주입받아 JPA batch insert 활용 가능 (`batch_size=100`)
- 실행 시간을 로깅하여 "1분 이내" 요구사항 충족 확인 가능

---

## 2. 예상 면접 질문 & 답변

### Q1. 다른 기술 스택은 고려하지 않았는가?

**A**: 고려했다. 주요 대안은 다음과 같다.

| 대안 | 검토 결과 |
|------|----------|
| **FastAPI (Python)** | Python 생태계에서는 H2를 사용할 수 없고, JPA의 `@Lock` 같은 선언적 동시성 제어가 없다. SQLAlchemy로 비관적 락을 구현할 수 있지만 Spring JPA 대비 보일러플레이트가 많다 |
| **Express/NestJS (Node.js)** | TypeORM/Prisma의 비관적 락 지원이 JPA보다 제한적이다. 특히 TypeORM의 pessimistic lock은 일부 DB에서만 동작한다 |
| **Spring WebFlux (리액티브)** | 비동기 논블로킹 방식이지만, 비관적 락은 블로킹 I/O를 전제로 하므로 리액티브와 본질적으로 충돌한다. 과제의 핵심이 동시성 제어인 만큼 Spring MVC가 적합하다 |

결론적으로, 과제 요구사항(동시성 제어, 별도 인프라 없이 실행, 대량 데이터 생성)에 Spring Boot + JPA + H2 조합이 가장 적합했다.

---

### Q2. AI가 생성한 코드에 대한 검증은 어떻게 진행했는가?

**A**: 3단계로 검증했다.

**1단계: 동시성 테스트로 핵심 요구사항 검증**

과제에서 가장 중요한 "정원 초과 절대 방지"를 자동화된 테스트로 검증했다.

```
- 정원 1명 × 100명 동시 신청 → 정확히 1명만 성공하는지 확인
- 정원 30명 × 100명 동시 신청 → 정확히 30명만 성공하는지 확인
- 동일 학생 중복 동시 신청 → 1번만 성공하는지 확인
- 신청/취소 동시 수행 → enrolled 카운트 정합성 확인
```

`ExecutorService` + `CountDownLatch`로 실제 멀티스레드 환경을 재현하여 테스트했다.

**2단계: 비즈니스 규칙 단위 테스트**

```
- 학점 초과(18학점), 시간 충돌, 중복 신청, 동일 과목 타 분반 등
  모든 비즈니스 규칙별 성공/실패 케이스를 테스트
- 경계값 테스트: 10:30 끝 → 10:30 시작은 충돌이 아님을 검증
```

**3단계: 코드 리뷰 수준의 직접 검토**

- 생성된 코드의 트랜잭션 범위가 적절한지 확인 (락 획득부터 커밋까지)
- N+1 쿼리 발생 가능성 검토 (FetchType.LAZY 설정 확인)
- 에러 응답 형식이 일관적인지 모든 API에서 확인
- Swagger UI로 모든 API를 직접 호출하여 정상 동작 확인

---

### Q3. 비관적 락의 단점은 무엇이고, 어떻게 개선할 수 있는가?

**A**: 주요 단점은 3가지다.

**1. 처리량(Throughput) 저하**

같은 강좌에 대한 요청이 직렬화되어 동시 처리가 불가능하다. 인기 강좌에 요청이 몰리면 응답 지연이 발생한다.

- **개선안**: 실제 프로덕션 환경에서는 Redis 분산 락 + 큐 기반으로 전환할 수 있다. 수강신청 요청을 큐에 넣고 비동기로 처리하면 사용자에게 즉시 "접수 완료" 응답을 주고, 결과는 폴링이나 WebSocket으로 알려주는 방식이다.

**2. 데드락 가능성**

두 트랜잭션이 서로 다른 순서로 여러 행을 잠그면 데드락이 발생할 수 있다.

- **현재 프로젝트에서의 안전성**: 수강신청 한 건당 Course 행 하나만 잠그기 때문에 데드락이 발생하지 않는 구조다. 다만 한 번에 여러 강좌를 동시 신청하는 기능을 추가한다면, 반드시 강좌 ID 오름차순으로 락을 획득하는 규칙이 필요하다.

**3. DB 커넥션 점유**

락 대기 중에도 DB 커넥션을 점유한다. 동시 요청이 많으면 커넥션 풀이 고갈될 수 있다.

- **개선안**: HikariCP의 `maximumPoolSize`와 `connectionTimeout`을 적절히 설정하고, JPA의 `javax.persistence.lock.timeout`으로 락 대기 시간에 상한을 두어 무한 대기를 방지한다.

---

### Q4. H2 대신 MySQL/PostgreSQL을 사용했다면 달라지는 점이 있는가?

**A**: 동시성 제어 측면에서 다음이 달라진다.

| 항목 | H2 | MySQL | PostgreSQL |
|------|:--:|:-----:|:----------:|
| 비관적 락 | O | O | O |
| 낙관적 락 | O | O | O |
| Named Lock | X | O (`GET_LOCK`) | O (`pg_advisory_lock`) |
| MVCC | 제한적 | O (InnoDB) | O |
| 데드락 감지 | 기본 타임아웃 | 자동 감지 + 롤백 | 자동 감지 + 롤백 |

MySQL이나 PostgreSQL을 사용했다면 Named Lock(네임드 락)을 추가 전략으로 고려할 수 있었다. Named Lock은 행 자체를 잠그지 않으므로 조회 성능에 영향을 주지 않는 장점이 있다. 또한 프로덕션 DB의 데드락 자동 감지 기능으로 안정성도 더 높다.

다만 현재 프로젝트는 "별도 인프라 설치 없이 실행"이 요구사항이므로 H2가 적합했고, 비관적 락은 H2에서도 정상 동작하기 때문에 기능적 차이는 없다.

---

### Q5. Scale-out(서버 다중화) 시 현재 구조에서 문제가 되는 부분은?

**A**: 크게 2가지 문제가 발생한다.

**1. H2 인메모리 DB → 서버별 별도 DB**

각 서버가 독립적인 인메모리 DB를 가지므로 데이터 정합성이 깨진다. MySQL/PostgreSQL 같은 외부 DB로 전환이 필수다.

**2. 비관적 락은 단일 DB에서만 유효**

외부 DB로 전환하면 비관적 락 자체는 여전히 동작한다 (같은 DB에 접근하므로). 하지만 처리량이 심각하게 저하될 수 있으므로, 다음 확장 전략을 고려할 수 있다.

```
[현재]
  단일 서버 + H2 + 비관적 락

[1차 확장]
  다중 서버 + MySQL/PostgreSQL + 비관적 락
  → DB가 공유되므로 동작은 하지만 성능 병목

[2차 확장]
  다중 서버 + Redis 분산 락 + MySQL/PostgreSQL
  → DB 락 대신 Redis로 락을 관리하여 커넥션 점유 최소화

[3차 확장]
  다중 서버 + MQ(Kafka) + MySQL/PostgreSQL
  → 수강신청을 큐에 넣고 순차 처리, 동시성 문제 구조적 제거
```

---

### Q6. enrolled 카운트를 Course 엔티티에 둔 이유는? Enrollment 테이블의 COUNT 쿼리로 대체할 수 없는가?

**A**: 대체할 수 있지만, 성능과 동시성 측면에서 현재 방식이 더 적합하다.

**COUNT 쿼리 방식의 문제**:
- 수강신청마다 `SELECT COUNT(*) FROM enrollment WHERE course_id = ?`를 실행해야 한다
- 이 쿼리 결과를 읽은 후 INSERT하는 사이에 다른 트랜잭션이 INSERT할 수 있다 (TOCTOU 문제)
- 비관적 락 없이는 정원 초과가 발생할 수 있고, 비관적 락을 쓰더라도 enrollment 테이블의 여러 행을 잠가야 한다

**현재 방식(enrolled 필드)의 장점**:
- Course 행 하나만 잠그면 정원 체크와 카운트 증가가 원자적으로 처리된다
- 조회 시에도 JOIN 없이 Course 테이블만으로 현재 수강 인원을 알 수 있다
- 정합성은 수강신청/취소 시 `increaseEnrolled()`/`decreaseEnrolled()` 호출로 보장한다

**트레이드오프**: enrolled 필드와 실제 Enrollment 레코드 수가 불일치할 가능성이 이론적으로 존재한다. 이는 동시성 테스트의 마지막 시나리오(신청/취소 동시 수행 → enrolled 카운트 = 실제 레코드 수 일치)로 검증했다.

---

### Q7. 시간 충돌 검증을 왜 애플리케이션 레벨에서 하는가? DB 제약으로 할 수 없는가?

**A**: DB 제약으로 시간 충돌을 처리하기 어렵다. 이유는 다음과 같다.

- 시간표 충돌은 **동일 학생의 기존 수강 목록** 전체와 비교해야 한다
- 단순 유니크 제약이 아니라 `start1 < end2 && start2 < end1`이라는 범위 비교 로직이 필요하다
- PostgreSQL의 EXCLUDE 제약조건으로 가능하지만, H2에서는 지원하지 않는다

따라서 EnrollmentService에서 해당 학생의 기존 수강 목록을 조회하고, 새 강좌의 시간표와 하나씩 비교하는 방식을 채택했다. 비관적 락으로 동시성 문제를 방지하고 있으므로, 검증 시점의 데이터는 신뢰할 수 있다.

---

### Q8. 에러 응답에서 비즈니스 규칙 위반을 왜 409 Conflict로 처리하는가?

**A**: HTTP 상태 코드 선택 기준은 다음과 같다.

| 상태 코드 | 사용처 | 예시 |
|-----------|--------|------|
| 400 Bad Request | 요청 형식 오류 | JSON 파싱 실패, 필수 필드 누락, 타입 불일치 |
| 404 Not Found | 리소스 미존재 | 학생/강좌/수강 기록이 없음 |
| **409 Conflict** | **현재 리소스 상태와 요청이 충돌** | **정원 초과, 학점 초과, 시간 충돌, 중복 신청** |

409를 선택한 이유는, 비즈니스 규칙 위반이 "요청 자체는 올바르지만 현재 서버 상태와 충돌하는 경우"에 해당하기 때문이다. 예를 들어, 같은 수강신청 요청이라도 정원이 남아있으면 성공하고, 꽉 차있으면 실패한다. 이는 요청의 문제(400)가 아니라 상태의 충돌(409)이다.

대안으로 422 Unprocessable Entity를 사용하는 경우도 있다. 422는 "요청은 이해했지만 처리할 수 없다"는 의미로, 비즈니스 검증 실패에 적합하다는 의견도 있다. 다만 이 프로젝트에서는 정원 초과나 시간 충돌이 명확히 "리소스 상태와의 충돌"이므로 409가 더 의미가 정확하다고 판단했다.

---

### Q9. 테스트 전략에서 통합 테스트와 단위 테스트를 어떻게 구분했는가?

**A**: 이 프로젝트에서는 2종류의 테스트를 작성했다.

**1. EnrollmentServiceTest (통합 테스트)**
- `@SpringBootTest`로 실제 Spring Context를 로드
- H2 인메모리 DB에서 실제 트랜잭션으로 비즈니스 규칙 검증
- 수강신청 성공/실패, 학점 초과, 시간 충돌, 중복 신청 등 모든 비즈니스 규칙 커버

**2. EnrollmentConcurrencyTest (동시성 통합 테스트)**
- `@SpringBootTest`로 실제 환경에서 멀티스레드 테스트
- `ExecutorService` + `CountDownLatch`로 동시 요청 시뮬레이션
- 비관적 락이 실제로 정원 초과를 방지하는지 검증

**순수 단위 테스트(Mock 기반)를 작성하지 않은 이유**:
- 핵심 검증 대상이 "DB 락이 실제로 동작하는지"이므로 Mock으로는 의미 없음
- 비즈니스 규칙도 JPA 쿼리 결과에 의존하므로, 실제 DB 연동 테스트가 더 신뢰성 높음
- 프로젝트 규모 대비 Mock 기반 단위 테스트를 별도로 작성하면 중복 유지보수 비용 발생

---

### Q10. Swagger 어노테이션을 인터페이스(docs)로 분리한 이유는?

**A**: 컨트롤러 클래스의 가독성을 유지하기 위해서다.

Swagger 어노테이션(`@Operation`, `@ApiResponse`, `@Parameter` 등)을 컨트롤러 메서드에 직접 붙이면, 실제 비즈니스 로직보다 문서화 어노테이션이 더 많은 줄을 차지한다. 이를 해결하기 위해 각 컨트롤러별 Docs 인터페이스를 만들고, 컨트롤러가 이 인터페이스를 구현하는 방식을 채택했다.

```
controller/
├── CourseController.java          ← 실제 로직만 포함 (간결)
└── docs/
    └── CourseControllerDocs.java   ← Swagger 어노테이션 집중
```

이 패턴은 컨트롤러 코드 리뷰 시 비즈니스 로직에 집중할 수 있게 해주고, Swagger 설정 변경 시에도 docs 파일만 수정하면 되어 변경 범위가 명확해진다.

---

### Q11. DataInitializer에서 대량 데이터 삽입 시 성능 최적화는 어떻게 했는가?

**A**: 3가지 최적화를 적용했다.

**1. Hibernate Batch Insert 설정**

```yaml
spring.jpa.properties.hibernate:
  jdbc.batch_size: 100
  order_inserts: true
  order_updates: true
```

100개씩 묶어서 INSERT하므로, 10,000명의 학생을 100번의 batch INSERT로 처리한다. 개별 INSERT 대비 네트워크 왕복(round-trip)이 100배 줄어든다.

**2. 학생 데이터 분할 저장**

10,000명을 한 번에 `saveAll()`하면 영속성 컨텍스트(1차 캐시)에 10,000개 엔티티가 쌓여 메모리 부담이 크다. 500명 단위로 분할하여 `saveAll()` 호출 후 flush/clear하는 방식으로 메모리 사용량을 제어했다.

**3. 실행 시간 로깅**

시작/종료 시간을 로깅하여 "1분 이내 완료" 요구사항을 충족하는지 매 실행마다 확인할 수 있다. 실측 약 5초 내외로 완료된다.

---

### Q12. 수강취소 시에도 비관적 락을 거는 이유는?

**A**: enrolled 카운트의 정합성을 보장하기 위해서다.

수강취소는 `enrolled` 값을 감소시킨다. 만약 락 없이 취소하면 다음 시나리오가 발생할 수 있다.

```
Thread A (취소): enrolled=30 읽음 → enrolled=29로 갱신
Thread B (신청): enrolled=30 읽음 → enrolled=31로 갱신  (A의 갱신이 덮어씌워짐)
결과: enrolled=31이지만 실제 수강 기록은 30건 → 불일치
```

비관적 락으로 Course 행을 잠그면 신청과 취소가 직렬화되어 이런 Lost Update 문제를 방지한다. 동시성 테스트의 "신청/취소 동시 수행" 시나리오로 이를 검증했다.

---

### Q13. 같은 과목 다른 분반 중복 방지를 어떻게 구현했는가?

**A**: Course 엔티티에 `baseName` 필드를 추가하여 해결했다.

```
예시:
- name: "자료구조 1분반"  →  baseName: "자료구조"
- name: "자료구조 2분반"  →  baseName: "자료구조"
```

수강신청 시 해당 학생이 이미 같은 `baseName`의 강좌를 수강 중인지 확인한다. 요구사항에 명시되지 않은 암묵적 규칙이지만, "자료구조 1분반을 수강 중인 학생이 자료구조 2분반을 추가 신청하는 것은 비합리적"이라고 판단하여 구현했다.

---

### Q14. 이 프로젝트에서 가장 어려웠던 부분은?

**A**: 동시성 제어 전략의 선택과 검증이다.

**전략 선택의 어려움**: 비관적 락, 낙관적 락, 분산 락, Named Lock, 큐 기반 등 5가지 전략을 비교 분석해야 했다. 각 전략의 장단점을 이해하고, "단일 서버 + H2 + 높은 경합"이라는 프로젝트 조건에 가장 적합한 전략을 선택하는 과정에서 트레이드오프 분석 능력이 필요했다.

**검증의 어려움**: 동시성 버그는 재현이 어렵다. 단순히 코드를 읽는 것만으로는 레이스 컨디션을 발견하기 어렵기 때문에, `ExecutorService`와 `CountDownLatch`를 활용한 멀티스레드 테스트를 설계하여 실제 동시 환경을 재현했다. 특히 "신청과 취소가 동시에 발생하는 시나리오"를 테스트하면서 enrolled 카운트와 실제 레코드 수의 일치를 검증하는 것이 까다로웠다.

---

### Q15. 강좌 조회 트래픽이 몰릴 때 캐싱 전략은 어떻게 설계하겠는가?

**A**: 수강신청 도메인의 특성을 분석하면, 일반적인 TTL 기반 캐싱보다 효과적인 전략을 도출할 수 있다.

**도메인 특성 분석**

수강신청 시 학생의 행동 패턴은 "강좌 목록 조회(여러 번) → 강좌 선택 → 수강신청(1번)"이다. 읽기:쓰기 비율이 약 10:1 이상이고, 5,000명이 동시에 목록을 반복 조회하면 동일한 쿼리가 초당 수만 건 발생한다.

여기서 핵심 통찰은 **수강신청은 정원이 단방향으로 차는 구조**라는 점이다.

```
정원 40 → 39 → 38 → ... → 1 → 0 (마감)
         ↑ 이 구간만 쓰기 발생       ↑ 이후 100% 캐시 히트
```

- 쓰기는 최대 40번(정원 수)만 발생하고, 마감 후에는 모든 조회가 캐시에서 처리된다
- 스파이크 구간에서 취소는 거의 발생하지 않는다
- 인기 강좌일수록 빨리 마감되어, 빨리 캐시 히트율 100%에 도달한다

**Write-Through 캐시 전략**

TTL 기반이 아니라, 수강신청/취소 시 캐시를 즉시 갱신하는 Write-Through 방식을 적용한다.

```
[GET /courses 조회]
  → 캐시 존재? → 캐시 반환 (DB 안 감)
  → 캐시 없음? → DB 조회 → 캐시 저장 → 반환

[POST /enrollments 수강신청]
  → DB 비관적 락 → 비즈니스 검증 → enrolled 증가 → DB 커밋
  → 캐시에 해당 강좌의 enrolled 값 갱신
```

**캐시 히트율 시뮬레이션**

정원 40명 강좌에 1,000명이 조회하는 상황:

```
요청 1~40   : 등록 성공 → 매 요청마다 캐시 갱신 (히트율 낮음)
요청 41~1000: 전부 캐시에서 "정원 마감" 응답 (히트율 100%)

전체 캐시 히트율: 960/1000 = 96%
```

인기 강좌(정원 30, 조회 5,000건)라면 히트율은 99%+다. 비인기 강좌는 정원이 안 차지만 애초에 조회 트래픽도 적어서 DB 부하에 영향이 미미하다.

**일반적인 TTL 캐싱 대비 장점**

| 항목 | TTL 기반 캐싱 | Write-Through 캐싱 |
|------|:-----------:|:-----------------:|
| stale 데이터 | TTL 만료 전까지 발생 | 없음 (매 쓰기마다 갱신) |
| 잔여 정원 정확도 | TTL에 따라 부정확 | 항상 정확 |
| 캐시 무효화 복잡도 | TTL 설정 고민 필요 | 단순 (등록/취소 시 갱신) |
| 구현 적합성 | 범용적 | 수강신청 도메인에 최적화 |

이 전략은 단순히 "캐싱을 적용했다"가 아니라, 도메인 특성(정원이 단방향으로 차고, 쓰기 횟수의 상한이 정원 수로 고정됨)을 분석하여 도출한 결과다.

---

### Q16. 프로젝트를 다시 한다면 개선하고 싶은 점은?

**A**: 3가지를 개선하겠다.

**1. Write-Through 캐싱 도입**

Q15에서 분석한 대로, 강좌 조회에 Write-Through 캐시를 적용하여 DB 부하를 줄이겠다. 단일 서버 환경에서는 Caffeine Local Cache로 충분하고, 다중 서버 전환 시 Redis로 교체할 수 있다.

**2. 인덱스 최적화**

현재 JPA 기본 생성 인덱스만 사용하고 있다. 수강신청 시 자주 조회되는 `enrollment(student_id)`, `enrollment(course_id)`, `course(base_name)` 등에 복합 인덱스를 추가하면 쿼리 성능이 개선된다.

**3. API 응답 페이지네이션**

학생 10,000명을 한 번에 반환하는 `GET /students`는 프로덕션 환경에서 문제가 된다. Spring Data의 `Pageable`을 활용한 커서/오프셋 기반 페이지네이션을 도입하겠다.